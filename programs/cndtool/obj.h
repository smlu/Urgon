#ifndef CNDTOOL_OBJ_H
#define CNDTOOL_OBJ_H
#include <libim/content/asset/material/texture.h>
#include <libim/content/asset/material/texutils.h>
#include <libim/content/asset/world/impl/serialization/cnd/cnd.h>
#include <libim/content/asset/world/impl/serialization/world_ser_common.h>
#include <libim/content/text/text_resource_writer.h>
#include <libim/io/binarystream.h>
#include <libim/io/filestream.h>
#include <libim/utils/utils.h>

#include "config.h"

#include <array>
#include <filesystem>
#include <string>
#include <string_view>
#include <stdexcept>

namespace cndtool {
    constexpr std::string_view kMtlFolder               = "mtl";
    constexpr std::string_view kMtlPngFolder            = "mtl/png";
    constexpr std::string_view kImgTransparentFileName  = "transparent.png";
    constexpr std::string_view kNewMtlTransparent       = "newmtl transparent";
    constexpr std::string_view kUseMtlTransparent       = "usemtl transparent";
    constexpr std::string_view kMapKdTransparent        = "map_Kd png/transparent.png";
    constexpr std::string_view kImgDefaultFileName      = "dflt.png";
    constexpr std::string_view kNewMtlDefault           = "newmtl dflt";
    constexpr std::string_view kUseMtlDefault           = "usemtl dflt";
    constexpr std::string_view kMapKdDefault            = "map_Kd png/dflt.png";

    constexpr std::array<unsigned char, 334> kImgTransparentPng = {
        0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0x06, 0x00, 0x00, 0x00, 0x5c, 0x72, 0xa8,
        0x66, 0x00, 0x00, 0x01, 0x15, 0x49, 0x44, 0x41, 0x54, 0x78, 0xda, 0xed, 0xc1, 0x31, 0x01, 0x00,
        0x00, 0x00, 0xc2, 0xa0, 0xf5, 0x4f, 0xed, 0x6b, 0x08, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x03, 0x01, 0x3c, 0x00, 0x01, 0xd8, 0x29,
        0x43, 0x04, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
    };

    constexpr std::array<unsigned char, 954> kImgDefaultPng = { // dflt.mat
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
        0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20,
        0x08, 0x02, 0x00, 0x00, 0x00, 0xFC, 0x18, 0xED, 0xA3, 0x00, 0x00, 0x03,
        0x81, 0x49, 0x44, 0x41, 0x54, 0x48, 0x89, 0x5D, 0x96, 0x31, 0x96, 0x20,
        0x37, 0x08, 0x44, 0xBF, 0x67, 0x09, 0x2A, 0xE8, 0x40, 0xC1, 0x1E, 0xC2,
        0x47, 0xF0, 0xFD, 0x4F, 0xE3, 0x50, 0xC1, 0x06, 0x15, 0x10, 0x38, 0x00,
        0xA4, 0x6E, 0xEB, 0xBD, 0x99, 0xE9, 0xE9, 0x96, 0x10, 0x14, 0x45, 0xC1,
        0x5F, 0xFF, 0xFC, 0xF3, 0x37, 0x66, 0x7B, 0x83, 0x96, 0x84, 0x00, 0x49,
        0xC2, 0xAE, 0xA7, 0xED, 0x6D, 0x53, 0x6F, 0x0C, 0xD8, 0x5A, 0xDA, 0xDB,
        0x67, 0x03, 0x60, 0xE8, 0x67, 0xD7, 0xE3, 0xFC, 0x2B, 0x7E, 0xFD, 0x7E,
        0x9E, 0x88, 0x20, 0x79, 0x24, 0x80, 0x00, 0x32, 0x12, 0xE3, 0x20, 0x22,
        0xC2, 0x49, 0x64, 0x12, 0xE9, 0x04, 0x1B, 0x29, 0x12, 0x32, 0x23, 0x22,
        0x22, 0xCA, 0xBA, 0xEA, 0x5C, 0x04, 0x11, 0x64, 0x1A, 0x02, 0x32, 0x33,
        0x9D, 0xBD, 0x03, 0x09, 0xE1, 0xED, 0x72, 0xC6, 0xD8, 0xB8, 0x63, 0xAA,
        0x65, 0xDE, 0xDE, 0xF1, 0x72, 0x56, 0xD7, 0x61, 0x24, 0x55, 0x94, 0xCC,
        0xC1, 0xD0, 0xCB, 0x84, 0xEB, 0xC3, 0x35, 0x74, 0x6C, 0x48, 0xE3, 0xE9,
        0x31, 0xFA, 0xFE, 0x84, 0x10, 0xB2, 0xDD, 0x0E, 0x4A, 0xB6, 0x0B, 0xB1,
        0xA0, 0x37, 0x50, 0xDF, 0x2A, 0x05, 0x6F, 0x1C, 0x3D, 0x01, 0x60, 0x6F,
        0x90, 0x1B, 0xFB, 0x4F, 0x40, 0x93, 0x23, 0xDB, 0xF7, 0xBC, 0x5D, 0x58,
        0xF9, 0x02, 0x50, 0x9F, 0x2A, 0x6F, 0xF6, 0x8D, 0xF4, 0x63, 0x0B, 0xCF,
        0x35, 0x9A, 0x98, 0x6C, 0xEF, 0x3A, 0xA2, 0x81, 0xA1, 0xC2, 0x32, 0xB1,
        0x77, 0x93, 0xC1, 0xC3, 0x16, 0x1D, 0xEB, 0xD7, 0xE0, 0x40, 0xDC, 0xBC,
        0x32, 0xB6, 0xCE, 0xAA, 0xE8, 0x8D, 0x07, 0xAE, 0x25, 0x35, 0x9E, 0x22,
        0x6E, 0x96, 0x90, 0x64, 0xBD, 0xF0, 0xE9, 0x60, 0x2C, 0xD6, 0x20, 0x08,
        0xC0, 0x92, 0x36, 0x5E, 0x92, 0x96, 0x2A, 0x73, 0x86, 0xFA, 0x4F, 0xA8,
        0x37, 0xEE, 0x8E, 0x23, 0x8E, 0x6D, 0x49, 0xAE, 0x70, 0x30, 0xF7, 0x9E,
        0xAA, 0x8C, 0x9B, 0xBA, 0x8E, 0xCC, 0x6C, 0xBC, 0x36, 0x88, 0x0E, 0x68,
        0xAD, 0xC3, 0x27, 0x0F, 0x80, 0x40, 0x48, 0x88, 0x26, 0x49, 0x81, 0xCB,
        0xA9, 0x29, 0x60, 0x6F, 0x4D, 0x62, 0xD4, 0x75, 0x66, 0x24, 0xAD, 0x35,
        0x74, 0xB0, 0xC0, 0x45, 0x1B, 0x64, 0xBC, 0x4F, 0x01, 0x56, 0x5D, 0x09,
        0x19, 0x6C, 0x4F, 0x36, 0x27, 0x07, 0x75, 0x8D, 0xB0, 0xA9, 0x37, 0x92,
        0x86, 0x94, 0x5A, 0x92, 0xB1, 0xF7, 0x5E, 0x6B, 0xB1, 0x9A, 0x21, 0xC5,
        0x45, 0x75, 0xE0, 0x08, 0x49, 0x8A, 0x53, 0x17, 0xE6, 0xB0, 0x54, 0x5A,
        0xAB, 0x6E, 0x2D, 0xA7, 0x2F, 0x71, 0x3D, 0xE8, 0x09, 0x76, 0x05, 0x6D,
        0x35, 0xA7, 0x3C, 0x36, 0x99, 0x6A, 0x05, 0x3B, 0x38, 0x78, 0x35, 0x2A,
        0xBE, 0xA5, 0xF0, 0x3F, 0x6D, 0x39, 0xEF, 0xC1, 0xDB, 0x83, 0x62, 0x53,
        0x69, 0x6E, 0xA8, 0x9A, 0x3B, 0xB9, 0x2F, 0x16, 0x7D, 0x98, 0xA3, 0x73,
        0xF4, 0xC5, 0xA4, 0xCF, 0xEA, 0x54, 0x8C, 0x43, 0xDB, 0x37, 0x65, 0x7E,
        0xC1, 0x5B, 0x67, 0xE3, 0xB8, 0x5F, 0x5C, 0x1E, 0xAC, 0x0A, 0x83, 0x0E,
        0x7A, 0x15, 0xDD, 0x35, 0xBB, 0xE6, 0x70, 0x97, 0x53, 0x67, 0xA0, 0x2F,
        0xEE, 0xD2, 0x1C, 0x48, 0x7F, 0x5E, 0xEE, 0xE9, 0xA5, 0x4B, 0xED, 0xA0,
        0x68, 0xEB, 0x75, 0x43, 0xF1, 0xE4, 0x8A, 0xD7, 0x18, 0x3B, 0xDA, 0x70,
        0x42, 0xD6, 0x04, 0x14, 0x87, 0x9A, 0x7A, 0x91, 0xD7, 0x9F, 0xDB, 0xD8,
        0xB6, 0xF7, 0xD6, 0x41, 0xA0, 0xBF, 0x1E, 0x49, 0x19, 0x97, 0x60, 0x4D,
        0x01, 0x6B, 0x90, 0x8D, 0xAE, 0x74, 0xEF, 0x7E, 0xA5, 0xDB, 0x6D, 0xCE,
        0xB1, 0x51, 0xBA, 0xC6, 0x10, 0xF0, 0xDE, 0x77, 0x3B, 0x14, 0x2E, 0xF2,
        0x30, 0xD1, 0x57, 0x7A, 0x63, 0x8A, 0xBB, 0xD5, 0xA3, 0xEF, 0xED, 0xC3,
        0xD3, 0x16, 0x28, 0x9D, 0xD1, 0x5A, 0xED, 0xC6, 0xDE, 0xFB, 0x93, 0xB6,
        0xBD, 0x0F, 0xCA, 0x6B, 0xAD, 0xBD, 0xF7, 0x49, 0xD5, 0x34, 0x9C, 0x43,
        0x18, 0xB3, 0xF7, 0xBF, 0x88, 0x92, 0x96, 0x0F, 0x83, 0xFC, 0xAA, 0xD2,
        0x26, 0x82, 0x06, 0xE1, 0xAE, 0x47, 0x3E, 0xE6, 0x00, 0x62, 0x7A, 0xC5,
        0x3E, 0x0A, 0xD4, 0xE1, 0xE0, 0xFB, 0xEB, 0x42, 0x7D, 0x33, 0x34, 0xBB,
        0x4F, 0x51, 0xF5, 0x8B, 0xBD, 0x77, 0x8B, 0x6B, 0xB5, 0xD2, 0xE9, 0x45,
        0x4D, 0xC6, 0xD2, 0x8C, 0x93, 0xC2, 0xDB, 0x0F, 0xBE, 0x3D, 0x72, 0xB5,
        0x2B, 0x5E, 0x5A, 0x65, 0x54, 0x9F, 0x01, 0x40, 0x87, 0x88, 0x3F, 0x7D,
        0x57, 0xFF, 0xB4, 0xF0, 0xD6, 0x2A, 0xF2, 0xBC, 0x1B, 0xEC, 0x9D, 0x1E,
        0x26, 0xA6, 0x52, 0x8B, 0x3A, 0xB3, 0xD6, 0x5A, 0x25, 0x82, 0x4D, 0xF1,
        0x1A, 0x06, 0x3C, 0x62, 0xE1, 0x83, 0xE5, 0xC8, 0xEB, 0x7D, 0x9E, 0x04,
        0x4E, 0x19, 0xF2, 0x56, 0xAA, 0x59, 0x7B, 0x58, 0xA4, 0xA1, 0x0C, 0xF0,
        0xEB, 0x59, 0x91, 0x4E, 0x45, 0x37, 0x67, 0x22, 0x04, 0xD4, 0xDC, 0x62,
        0x13, 0xF1, 0x3C, 0xF1, 0x84, 0xD2, 0x46, 0x04, 0xD1, 0x3D, 0x36, 0x33,
        0x23, 0x22, 0xF3, 0x59, 0x82, 0xC8, 0xCC, 0xAC, 0x94, 0x46, 0x56, 0x66,
        0x23, 0x89, 0x88, 0x78, 0xE2, 0xE7, 0xB4, 0x2A, 0xDB, 0xDE, 0xAD, 0x61,
        0xAE, 0x3E, 0xBA, 0xD6, 0x3A, 0xBA, 0x3E, 0xBE, 0xF1, 0xCD, 0xCE, 0x0D,
        0x70, 0xE4, 0xA6, 0xA5, 0x6E, 0x42, 0x8B, 0x0F, 0x13, 0xBF, 0xD5, 0xDB,
        0x9D, 0x64, 0x6A, 0xAA, 0x5A, 0xCA, 0x65, 0x11, 0x1E, 0x69, 0xE3, 0x28,
        0xF6, 0x9D, 0x1C, 0x06, 0xBF, 0x78, 0x91, 0xFA, 0x76, 0x15, 0x04, 0xDD,
        0x3D, 0x0F, 0x59, 0x3D, 0x4A, 0xAC, 0x29, 0xF0, 0x16, 0xB8, 0xDB, 0x49,
        0x98, 0x09, 0xA8, 0x4B, 0xD4, 0xBB, 0xEB, 0xE0, 0x54, 0xB6, 0x34, 0xE2,
        0xF8, 0xA1, 0x8B, 0xA4, 0x57, 0xA7, 0xBA, 0xF7, 0xAE, 0x75, 0x00, 0x9C,
        0x51, 0xA6, 0x25, 0xED, 0x4E, 0x21, 0xBF, 0x7E, 0x3F, 0xCF, 0x9F, 0xCC,
        0xA8, 0x59, 0xB3, 0x3C, 0xC8, 0x34, 0x10, 0x81, 0x1D, 0x4F, 0x84, 0x42,
        0x21, 0x22, 0x23, 0x71, 0xA6, 0x22, 0x92, 0xC4, 0x99, 0x50, 0x6F, 0x93,
        0xAC, 0xC2, 0x72, 0x92, 0x7F, 0xFE, 0x9C, 0xB3, 0x92, 0x7A, 0x7A, 0xBD,
        0xAB, 0xC3, 0xE2, 0x26, 0x71, 0x08, 0xBC, 0xED, 0xA9, 0xA3, 0x57, 0x4B,
        0x58, 0x2D, 0xE0, 0x2F, 0x9F, 0x85, 0xDF, 0x3D, 0x91, 0x9F, 0x99, 0x14,
        0x6E, 0x9E, 0xAF, 0x90, 0xF6, 0xDF, 0xA9, 0xAF, 0x8F, 0x2F, 0x3D, 0x0C,
        0x9E, 0xD6, 0x79, 0x72, 0x47, 0xCF, 0x29, 0xBD, 0xFD, 0x3F, 0x5F, 0xA9,
        0xD0, 0xE1, 0x02, 0xF0, 0xA1, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45,
        0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
    };

    void convertCndToObj(const std::filesystem::path& inCndPath, const std::filesystem::path& outFolder, bool extractMat)
    {
        using namespace libim;
        using namespace libim::content::asset;
        using namespace std::string_literals;
        namespace fs = std::filesystem;

        InputFileStream icnds(inCndPath);
        auto mats   = CND::readMaterials(icnds);
        auto geores = CND::readGeoresource(icnds);
        if (geores.verts.empty()) {
            throw std::runtime_error("CND file has no geometry resources");
        }

        HashMap<std::reference_wrapper<const Material>> usedMats;
        const auto mtlPath = kMtlFolder / fs::path(inCndPath).filename().replace_extension(".mtl");

        // Write obj
        {
            const auto objOutPath = outFolder / fs::path(inCndPath).filename().replace_extension(".obj");
            makePath(objOutPath);

            OutputFileStream objs(objOutPath, /*truncate=*/true);
            TextResourceWriter rw(objs);
            rw.setIndentCh('\t');
            rw.writeCommentLine("% v% OBJ file: %", kProgramName, kVersion, objOutPath.filename().u8string());
            rw.writeCommentLine(kProgramUrl);
            rw.writeEol();

            rw.writeLine("mtllib " + std::string(kMtlFolder) + "/" + mtlPath.filename().string());
            rw.writeLine("o " + mtlPath.filename().stem().string());

            // Write vertices
            for (const auto& v : geores.verts)
            {
                rw.write("v");
                rw.writeVector(v, /*indent=*/ 1);
                rw.writeEol();
            }

            rw.writeEol();
            for (const auto& uv : geores.texVerts)
            {
                rw.write("vt");
                rw.writeVector(Vector2f(uv.x(), -uv.y()), /*indent=*/ 1); // UV.y is flipped as Mat texture is stored top-to-bottom
                rw.writeEol();
            }
            rw.writeEol();


            // Write surfaces & vertex normals to buffers
            std::vector<std::vector<Vector3f>> fnormals(geores.verts.size()); // face normals that share the same vertex

            std::vector<byte_t> fbuffer;
            fbuffer.reserve(geores.surfaces.size() * (/*usemtl + name*/6 + 64 + /*f*/ 2 + 4 + 4 + 4));
            OutputBinaryStream<decltype(fbuffer)> bs(fbuffer);
            TextResourceWriter brw(bs);
            for (const auto& s : geores.surfaces)
            {
                // Write texture to use with face
                const auto matIdx = fromOptionalIdx(s.matIdx);
                if (matIdx != -1 && matIdx < mats.size())
                {
                    const auto& mat = mats.at(matIdx);
                    usedMats.pushBack(mat.name(), mat);
                    brw.writeLine("usemtl " + fs::path(mat.name()).stem().string());
                }
                else if (matIdx == 33092) {  // 33092 -> 324: "dflt.mat" in jones3dstatic i.e. 33092 -> 0x8144 & ~0x8000 = 324
                    brw.writeLine(kUseMtlDefault);
                }
                else {
                    brw.writeLine(kUseMtlTransparent);
                }

                // Write face vertex and UV incices
                brw.write("f\t");
                for (const auto& v : s.verts)
                {
                    brw.writeNumber(v.vertIdx + 1); // Note: idx in obj starts at 1
                    brw.write("/");
                    auto uvIdx = fromOptionalIdx(v.uvIdx) + 1; // Note: idx in obj starts at 1
                    if (uvIdx > 0) {
                        brw.writeNumber(uvIdx);
                    }
                    brw.write("/");
                    brw.writeNumber(v.vertIdx + 1); // normal idx. Note: idx in obj starts at 1
                    brw.indent(1);

                    // Write vertex normal
                    fnormals[v.vertIdx].push_back(s.normal);
                }
                brw.writeEol();
            }

            // Calculate & write vertex normals
            int i = 0;
            for (const auto& fn : fnormals)
            {
                auto vn = unweightedVertexNormal(fn);
                rw.write("vn");
                rw.writeVector(vn, /*indent=*/ 1);
                rw.writeEol();
                i++;
            }
            rw.writeEol();

            // Write object mesh faces
            objs << fbuffer;
        }

        // Write mtl
        {
            const auto mtlOutPath = outFolder / mtlPath;
            makePath(mtlOutPath);

            OutputFileStream mtls(mtlOutPath);
            TextResourceWriter rw(mtls);
            rw.setIndentCh(' ');
            rw.writeCommentLine("% v% MTL file: %", kProgramName, kVersion, mtlOutPath.filename().u8string());
            rw.writeCommentLine(kProgramUrl);
            rw.writeCommentLine("Material Count: %", usedMats.size() + 2); // +2 =  transparent img + default image
            rw.writeEol();

            // Add transparent & default material at the the top of the list
            rw.writeLine(kNewMtlTransparent);
            rw.writeLine("Tr 1.0");
            rw.writeLine("Ks 0 0 0");
            rw.writeLine("Ns 0");
            rw.writeLine(kMapKdTransparent);
            rw.writeEol();

            rw.writeLine(kNewMtlDefault);
            rw.writeLine("Ks 0 0 0");
            rw.writeLine("Ns 0");
            rw.writeLine(kMapKdDefault);
            rw.writeEol();

            auto writeImage = [&](const auto& imgName, const auto& imgData) {
                auto matPath = outFolder / kMtlPngFolder / imgName;
                if (!fileExists(matPath))
                {
                    makePath(matPath);
                    auto nWritten = OutputFileStream(matPath, /*truncate=*/true)
                        .write(imgData.data(), imgData.size());
                    if (nWritten != imgData.size()) {
                        throw std::runtime_error(
                            "Failed to write file " + std::string(imgName)
                        );
                    }
                }
            };

            // Write transparent & default image to mat folder if it doesn't exists
            writeImage(kImgTransparentFileName, kImgTransparentPng);
            writeImage(kImgDefaultFileName, kImgDefaultPng);

            for (const auto& m : usedMats)
            {
                const auto name = fs::path(m.get().name()).stem().string();
                if (extractMat)
                {
                    const auto matOutPath =  outFolder / kMtlPngFolder / (name + ".png");
                    makePath(matOutPath);
                    pngWrite(OutputFileStream(matOutPath, /*truncate=*/true), m.get().cells().at(0));
                }

                rw.writeLine("newmtl " + name);
                rw.writeLine("Ks 0 0 0");
                rw.writeLine("Ns 0"); // No shine
                rw.writeLine("map_Kd " + std::string(kMtlFolder) + "/" + name + ".png");
                rw.writeEol();
            }
        }
    }
}

#endif // CNDTOOL_OBJ_H
